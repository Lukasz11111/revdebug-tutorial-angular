<!doctype html>
<html lang="en">
<head><!--4v1&x*R2JB4g~4t@SQ+4%.y;0jGKPq:7--><script>var __revdLoaded = false; try { if (__RevDeBug) __revdLoaded = true; } catch {} if (!__revdLoaded) { let _global; const revd = {}; revd.isNode = (new Function('try{return this===global;}catch{return false;}'))(); revd.isV8 = revd.isNode || (Error.captureStackTrace !== undefined); if (revd.isNode) _global = global; else { _global = null; if (_global === null) { try { globalThis.__revdGlobalTest = true; if (__revdGlobalTest === true) _global = globalThis; delete globalThis.__revdGlobalTest; } catch { try { delete globalThis.__revdGlobalTest; } catch {}}} if (_global === null) { try { self .__revdGlobalTest = true; if (__revdGlobalTest === true) _global = self ; delete self .__revdGlobalTest; } catch { try { delete self .__revdGlobalTest; } catch {}}} if (_global === null) { try { this .__revdGlobalTest = true; if (__revdGlobalTest === true) _global = this ; delete this .__revdGlobalTest; } catch { try { delete this .__revdGlobalTest; } catch {}}} if (_global === null) { try { window .__revdGlobalTest = true; if (__revdGlobalTest === true) _global = window ; delete window .__revdGlobalTest; } catch { try { delete window .__revdGlobalTest; } catch {}}} if (_global === null) throw new Error('RevDeBug could not determine global scope!'); } _global.__RevDeBug = revd; revd.global = _global; revd.isInit = false; revd.version = "1.0.0a140"; const Object = _global.Object; const DataView = _global.DataView; const Uint8Array = _global.Uint8Array; const Int32Array = _global.Int32Array; const objDefProp = _global.Object.defineProperty; let textEncode; let textDecode; let pathSep; let env; let Connection; let initSystem; if (revd.isNode) { pathSep = process.platform === 'win32' ? '\\' : '/'; env = process.env; let net, waitForImports; try { net = require('net'); let util = require('util'); const textEncoder = new util.TextEncoder(); const textDecoder = new util.TextDecoder(); textEncode = textEncoder.encode.bind(textEncoder); textDecode = textDecoder.decode.bind(textDecoder); waitForImports = (callback) => callback(); } catch { let imports = [ import('net').then((mod) => net = mod), import('util').then((mod) => { const textEncoder = new mod.TextEncoder(); const textDecoder = new mod.TextDecoder(); textEncode = textEncoder.encode.bind(textEncoder); textDecode = textDecoder.decode.bind(textDecoder); }) ]; waitForImports = (callback) => { Promise.all(imports).then(() => { waitForImports = (callback) => callback(); callback(); }); }; } Connection = class { constructor(host, port, onconnect, onfail, onclose, ondata) { waitForImports((function() { this.listeners = {}; this.connected = false; this.asyncClose = false; this.sock = new net.Socket(); this.on('error', onfail); this.sock.setTimeout(5000, (function() { setTimeout((function() { if (!this.connectedOnce) { this.sock.destroy(); if (onfail) onfail(); } }).bind(this), 0); }).bind(this)); this.sock.connect(port, host, (function() { this.connectedOnce = true; this.connected = true; this.sock.setTimeout(0); this.sock.on('close', this.onclose.bind(this)); this.on('error', null); this.on('close', onclose); this.on('data', ondata); onconnect(); }).bind(this)); }).bind(this)); } on(event, func) { if (event !== 'close') { const old_func = this.listeners[event]; if (old_func) this.sock.removeListener(event, old_func); if (func) this.sock.on(event, func); } this.listeners[event] = func; } unref() { this.sock.unref(); } onclose() { if (this.connected || this.asyncClose) { this.connected = false; const onclose = this.listeners['close']; if (onclose) onclose(); } } close(emitClose = true) { if (this.connected) { this.connected = false; try { this.sock.end(); } catch {} if (emitClose === null) this.asyncClose = true; else if (emitClose) { const onclose = this.listeners['close']; if (onclose) onclose(); } } } send(data, emitClose = true) { if (this.connected) { try { this.sock.write(data); return true; } catch { this.connected = false; try { this.sock.destroy(); } catch {} if (emitClose) { const onclose = this.listeners['close']; if (onclose) onclose(); } } } return false; } }; initSystem = function() { process.on('beforeExit', (function() { this.setRecMode(RecMode_Off, null); }).bind(this)); process.on('uncaughtException', (function(err) { console.error(err); this.unhandled(err, undefined, true); this.setRecMode(RecMode_Off, null); }).bind(this)); process.on('unhandledRejection', (function(err) { console.error('UnhandledPromiseRejectionWarning:', err); this.unhandled(err); }).bind(this)); }; } else { const textEncoder = new TextEncoder(); const textDecoder = new TextDecoder(); textEncode = textEncoder.encode.bind(textEncoder); textDecode = textDecoder.decode.bind(textDecoder); pathSep = '/'; env = {}; let socketId = 0; Connection = class { constructor(host, port, onconnect, onfail, onclose, ondata) { this.id = socketId++; this.connected = false; this.asyncClose = false; this.sock = new WebSocket(`ws://${host}:${port}`); this.sock.onerror = onfail; this._onclose = null; this._ondata = null; this.sock.onopen = (function() { this.connected = true; this.sock.onerror = null; this.sock.onclose = this.onclose.bind(this); this.sock.onmessage = this.onmessage.bind(this); this._onclose = onclose; this._ondata = ondata; onconnect(); }).bind(this); } unref(){} on(event, func) { if (event === 'close') this._onclose = func; else if (event === 'data') this._ondata = func; } onmessage(msg) { msg.data.arrayBuffer().then((function(ab) { if (this.connected && this._ondata) this._ondata(new Uint8Array(ab)); }).bind(this)); } onclose() { if (this.connected || this.asyncClose) { this.connected = false; if (this._onclose) this._onclose(); } } close(emitClose = true) { if (this.connected) { this.connected = false; try { this.sock.close(); } catch {} if (emitClose === null) this.asyncClose = true; else if (emitClose && this._onclose) this._onclose(); } } send(data, emitClose = true) { if (this.connected) { try { this.sock.send(data); return true; } catch { this.connected = false; try { this.sock.close(false); } catch {} if (emitClose && this._onclose) this._onclose(); } } return false; } }; initSystem = function() { addEventListener('beforeunload', (function() { this.setRecMode(RecMode_Off, null); }).bind(this)); addEventListener('error', (function(e) { if (e.error !== null) this.unhandled(e.error); }).bind(this)); addEventListener('unhandledrejection', (function(e) { if (e.reason !== null) this.unhandled(e.reason); }).bind(this)); }; } const RecMode_Off = 1; const RecMode_Live = 3; const RecMode_Crash = 4; const FrameType_Update = 0x01; const FrameType_Handshake = 0x42; const FrameType_AppState = 0x15; const FrameType_DownloadRecording = 0x17; const FrameType_SaveLastStates = 0x20; const FrameType_KeepAlive = 0x25; const FrameType_Snapshot = 0x26; const packetKeepAlive = new Uint8Array([0, 0, 0, 0, FrameType_KeepAlive]); const packetRespHandshake = new Uint8Array([0, 0, 0, 0, FrameType_Handshake]); const packetRespHandshakeOff = new Uint8Array([1, 0, 0, 0, FrameType_Update, RecMode_Off, 0, 0, 0, 0, FrameType_Handshake]); const packetRespHandshakeCrash = new Uint8Array([1, 0, 0, 0, FrameType_Update, RecMode_Crash, 0, 0, 0, 0, FrameType_Handshake]); const packetRespHandshakeLive = new Uint8Array([1, 0, 0, 0, FrameType_Update, RecMode_Live, 0, 0, 0, 0, FrameType_Handshake]); const packetRespDownloadRecording = new Uint8Array([0, 0, 0, 0, FrameType_DownloadRecording]); const arrayCompare = (a, b) => a.every((v, i) => v === b[i]); const abort = () => process.exit(1); const nop = () => undefined; const connect = function(isLive, onconnect, onfail, onclose, ondata) { const conn = new Connection(this.host, this.port, (function() { conn.send(pack_TcpFrame_Handshake(this.Sol, this.App, this.Auth, 1000, this.Rel, isLive)); }).bind(this), onfail, onfail, (function(data) { if (!arrayCompare(data, packetRespHandshake) && !arrayCompare(data, packetRespHandshakeOff) && !arrayCompare(data, packetRespHandshakeCrash) && !arrayCompare(data, packetRespHandshakeLive)) conn.close(); else { conn.on('close', onclose); conn.on('data', ondata); onconnect(data[5]); } }).bind(this), ); return conn; }; const sendException = function(states, exit) { const done = exit ? abort : nop; const conn = connect.call(this, false, (function() { conn.send(pack_TcpFrame_Exception(this.Sol, states[states.length - 1], this.Rel)); }).bind(this), done, done, (function(data) { if (arrayCompare(data, packetRespDownloadRecording)) conn.send(pack_TcpFrame_State(FrameType_DownloadRecording, states)); conn.close(null); }).bind(this) ); }; const onConnect = function(recMode) { const queue = this.queue; this.queue = null; this.conn.unref(); if (recMode === RecMode_Live) { if (!this.conn.send(pack_TcpFrame_AppBeat(this.Rel, this.Sol, true), false)) recMode = RecMode_Off; else { for (const tcpFrame of queue) { if (!this.conn.send(tcpFrame, false)) { recMode = RecMode_Off; break; } } } if (recMode !== RecMode_Live) { this.conn.on('data', null); this.conn.close(false); this.recMax = RecMode_Off; this.conn = null; } } if (recMode === RecMode_Off) setRecMode_off.call(this); else if (recMode === RecMode_Crash) setRecMode_crash.call(this); }; const onClose = function() { this.queue = null; this.conn = null; setRecMode_off.call(this); }; const onData = function(data) { const end = data.length; for (let frameLen, i = 0; i < end; i += 5 + frameLen) { frameLen = data[i] + (data[i + 1] << 8) + (data[i + 2] << 16) + (data[i + 3] << 24); const frameType = data[i + 4]; if (frameType === FrameType_KeepAlive) { if (!this.conn.send(packetKeepAlive)) break; } else if (frameType === FrameType_Update) { this.setRecMode(frameLen ? data[i + 5] : RecMode_Off, !frameLen); } else if (frameType === FrameType_Snapshot) { const lName = data[i + 5] + (data[i + 6] << 8) + (data[i + 7] << 16) + (data[i + 8] << 24); const name = textDecode(new DataView(data.buffer, i + 9, lName)); this.snapshot(name); } } }; const lenArrays = (arrays) => arrays.reduce((a, b) => a + b.length, 0); const pack_CatchState = function(ApplicationId, StatementId, Timestamp, ExceptionMessage, IsUnhandled, StackTrace, TypeName) { let l0 = ExceptionMessage.length; let l1 = StackTrace.length; let l2 = TypeName.length; let p0 = 49 + l0; let p1 = p0 + 5 + l1; let p2 = p1 + 4 + l2; let u8 = new Uint8Array(p2); u8[0] = 0; u8[1] = 16; u8.set(ApplicationId, 5); u8[21] = u8[22] = u8[23] = u8[24] = u8[25] = u8[26] = u8[27] = u8[28] = -1; u8[29] = StatementId & 255; u8[30] = StatementId >> 8 & 255; u8[31] = StatementId >> 16 & 255; u8[32] = StatementId >> 24 & 255; u8.set(Timestamp, 33); u8[45] = l0 & 255; u8[46] = l0 >> 8 & 255; u8[47] = l0 >> 16 & 255; u8[48] = l0 >> 24 & 255; u8.set(ExceptionMessage, 49); u8[p0] = IsUnhandled; u8[p0 + 1] = l1 & 255; u8[p0 + 2] = l1 >> 8 & 255; u8[p0 + 3] = l1 >> 16 & 255; u8[p0 + 4] = l1 >> 24 & 255; u8.set(StackTrace, p0 + 5); u8[p1] = l2 & 255; u8[p1 + 1] = l2 >> 8 & 255; u8[p1 + 2] = l2 >> 16 & 255; u8[p1 + 3] = l2 >> 24 & 255; u8.set(TypeName, p1 + 4); return u8; }; const pack_StaticState = function(ApplicationId, StatementId, Timestamp) { let u8 = new Uint8Array(46); u8[0] = 2; u8[1] = 16; u8.set(ApplicationId, 5); u8[21] = u8[22] = u8[23] = u8[24] = u8[25] = u8[26] = u8[27] = u8[28] = -1; u8[29] = StatementId & 255; u8[30] = StatementId >> 8 & 255; u8[31] = StatementId >> 16 & 255; u8[32] = StatementId >> 24 & 255; u8.set(Timestamp, 33); return u8; }; const pack_MethodState = function(ApplicationId, StatementId, Timestamp, MethodPhase) { let u8 = new Uint8Array(46); u8[0] = 1; u8[1] = 16; u8.set(ApplicationId, 5); u8[21] = u8[22] = u8[23] = u8[24] = u8[25] = u8[26] = u8[27] = u8[28] = -1; u8[29] = StatementId & 255; u8[30] = StatementId >> 8 & 255; u8[31] = StatementId >> 16 & 255; u8[32] = StatementId >> 24 & 255; u8.set(Timestamp, 33); u8[45] = MethodPhase; return u8; }; const pack_VariableState = function(ApplicationId, StatementId, Timestamp, Value) { let l0 = Value.length; let u8 = new Uint8Array(l0 + 65); u8[0] = 3; u8[1] = 16; u8.set(ApplicationId, 5); u8[21] = u8[22] = u8[23] = u8[24] = u8[25] = u8[26] = u8[27] = u8[28] = -1; u8[29] = StatementId & 255; u8[30] = StatementId >> 8 & 255; u8[31] = StatementId >> 16 & 255; u8[32] = StatementId >> 24 & 255; u8.set(Timestamp, 33); u8[45] = u8[46] = u8[47] = u8[48] = -1; u8[49] = u8[50] = u8[51] = u8[52] = u8[53] = u8[54] = u8[55] = u8[56] = -1; u8[57] = l0 & 255; u8[58] = l0 >> 8 & 255; u8[59] = l0 >> 16 & 255; u8[60] = l0 >> 24 & 255; u8.set(Value, 61); return u8; }; const pack_TcpFrame_Handshake = function(SolutionName, ApplicationName, AuthorizationToken, BacklogSize, Release, isLiveRecorder) { let l0 = SolutionName.length; let l1 = ApplicationName.length; let l2 = AuthorizationToken.length; let l3 = Release.length; let p0 = l0 + 17; let p1 = l1 + 4 + p0; let p2 = l2 + 4 + p1; let p3 = l3 + 8 + p2; let u8 = new Uint8Array(p3 + 1); let dv = new DataView(u8.buffer); dv.setInt32(0, u8.length - 5, true); dv.setInt8(4, 0x42); dv.setInt32(5, 2, true); dv.setInt32(9, 0); dv.setInt32(13, l0, true); u8.set(SolutionName, 17); dv.setInt32(p0, l1, true); u8.set(ApplicationName, p0 + 4); dv.setInt32(p1, l2, true); u8.set(AuthorizationToken, p1 + 4); dv.setInt32(p2, BacklogSize, true); dv.setInt32(p2 + 4, l3, true); u8.set(Release, p2 + 8); dv.setInt8(p3, isLiveRecorder); return u8; }; const pack_TcpFrame_AppBeat = function(Release, SolutionName, keepConnection) { let l0 = Release.length; let l1 = SolutionName.length; let p0 = l0 + 9; let p1 = l1 + 4 + p0; let u8 = new Uint8Array(p1 + 1); let dv = new DataView(u8.buffer); dv.setInt32(0, u8.length - 5, true); dv.setInt8(4, 0x23); dv.setInt32(5, l0, true); u8.set(Release, 9); dv.setInt32(p0, l1, true); u8.set(SolutionName, p0 + 4); dv.setInt8(p1, keepConnection); return u8; }; const pack_TcpFrame_State = function(FrameType, states) { let lTcpFrame = lenArrays(states); let nStates = states.length; let u8 = new Uint8Array(5 + lTcpFrame); let dv = new DataView(u8.buffer); dv.setInt32(0, lTcpFrame, true); dv.setInt8(4, FrameType, true); for (let i = 0, pos = 5; i < nStates; i++) { let state = states[i]; u8.set(state, pos); pos += state.length; } return u8; }; const pack_TcpFrame_Exception = function(SolutionName, CatchState, Release) { let lSolutionName = SolutionName.length; let lCatchState = CatchState.length; let lRelease = Release.length; let pSolutionName = 9 + lSolutionName; let pCatchState = pSolutionName + 4 + lCatchState; let pRelease = pCatchState + 4 + lRelease; let u8 = new Uint8Array(pRelease); let dv = new DataView(u8.buffer); dv.setInt32(0, pRelease - 5, true); dv.setInt8(4, 0x1c, true); dv.setInt32(5, lSolutionName, true); u8.set(SolutionName, 9); dv.setInt32(pSolutionName, lCatchState, true); u8.set(CatchState, pSolutionName + 4); dv.setInt32(pCatchState, lRelease, true); u8.set(Release, pCatchState + 4); return u8; }; const pack_TcpFrame_Snapshot = function(SolutionName, Release, name, states) { let lSolutionName = SolutionName.length; let lRelease = Release.length; let lName = name.length; let pSolutionName = 9 + lSolutionName; let pRelease = pSolutionName + 4 + lRelease; let pName = pRelease + 4 + lName; let lStates = lenArrays(states); let lTcpFrame = pName - 1 + lStates; let nStates = states.length; let u8 = new Uint8Array(5 + lTcpFrame); let dv = new DataView(u8.buffer); dv.setInt32(0, lTcpFrame, true); dv.setInt8(4, 0x26, true); dv.setInt32(5, lSolutionName, true); u8.set(SolutionName, 9); dv.setInt32(pSolutionName, lRelease, true); u8.set(Release, pSolutionName + 4); dv.setInt32(pRelease, lName, true); u8.set(name, pRelease + 4); dv.setInt32(pName, lStates, true); for (let i = 0, pos = pName + 4; i < nStates; i++) { let state = states[i]; u8.set(state, pos); pos += state.length; } return u8; }; const MutMode_None = 0; const MutMode_Dirty = 1; const MutMode_Full = 2; const objProto = Object.prototype; const antiCircular = new Set(); const errAsValue = {}; let strMax, strHalf, strHalfN; const str_Function = (obj) => { const name = obj.name; const type = obj.constructor.name; return name && !name.startsWith('__revD') ? `[${type}: ${name}]` : `[${type}]`; }; const str_Boolean = (obj) => { if (!obj) return 'false'; else if (typeof obj === 'boolean') return 'true'; return obj.valueOf() ? 'Boolean(true)' : 'Boolean(false)'; }; const str_Number = (obj) => { if (typeof obj === 'number') return obj.toString(); return `Number(${obj.toString()})`; }; const str_BigInt = (obj) => { const str = obj.toString(); const len = str.length - strMax; return len <= 0 ? str + 'n' : `${str.slice(0, strHalf)} ... <${len.toString()} digits> ... ${str.slice(strHalfN)}n`; }; const str_String = (obj) => { if (obj.startsWith('\u200d')) return obj; const str = JSON.stringify(obj); const len = str.length - strMax; if (typeof obj === 'string') return len <= 0 ? str : `${str.slice(0, strHalf)} ... <${len.toString()} chars> ... ${str.slice(strHalfN)}`; return len <= 0 ? `String(${str})` : `String(${str.slice(0, strHalf)} ... <${len.toString()} chars> ... ${str.slice(strHalfN)})`; }; const str_Array = function() { const len = this.length; if (!len) return '[]'; if (antiCircular.has(this)) return '[Circular]'; antiCircular.add(this); let ret; const first = str(this[0]); if (len === 1) ret = `[${first}]`; else { const lFirst = first.length; if (lFirst >= strMax) { ret = `[${first}, ... <${len - 1} objs>]` } else { const head = [first]; const tail = []; let lTotal = lFirst; let iHead = 1; let iTail = len; while (true) { let s = str(this[--iTail]); tail.push(s); if (iHead === iTail || (lTotal += s.length) >= strMax) break; s = str(this[iHead++]); head.push(s); if (iHead === iTail || (lTotal += s.length) >= strMax) break; } tail.reverse(); const missing = iTail - iHead; if (!missing) ret = `[${head.join(', ')}, ${tail.join(', ')}]`; else ret = `[${head.join(', ')}, ... <${missing} objs> ..., ${tail.join(', ')}]`; } } antiCircular.delete(this); return ret; }; let instanceIdx = 0; const str_Object = function() { if (this.__proto__ !== objProto) { try { objDefProp(this.__proto__, '__revdstr', {configurable: true, writable: true, value: str_Instance}); if (this.__revdrec === rec_Object) objDefProp(this.__proto__, '__revdrec', {configurable: true, writable: true, value: false}); } catch {} return str_Instance.call(this); } if (antiCircular.has(this)) return '[Circular]'; const keys = Object.keys(this); const len = keys.length; if (!len) return '{}'; antiCircular.add(this); let ret; const firstKey = keys[0]; const first = str(this[firstKey]); if (len === 1) ret = `{${firstKey}: ${first}}`; else { const lFirst = first.length; if (lFirst >= strMax) { ret = `{${firstKey}: ${first}, ... <${len - 1} props>]` } else { const props = [first]; let lTotal = lFirst; let idx = 1; while (true) { const k = keys[idx++]; const s = str(this[k]); props.push(s); if (idx >= len || (lTotal += s.length + k.length) >= strMax) break; } const missing = len - idx; if (!missing) ret = `{${keys.map((k, i) => `${k}: ${props[i]}`).join(', ')}}`; else ret = `{${keys.slice(0, idx).map((k, i) => `${k}: ${props[i]}`).join(', ')}, ... <${missing} props>}`; } } antiCircular.delete(this); return ret; }; const nameInstance = (inst, name) => { try { objDefProp(inst, '__revdinststr', {configurable: true, writable: true, value: name = `[${name}-${++instanceIdx}]`}); } catch {} return name; }; const str_Instance = function() { const revdrec = this.__revdrec; if (revdrec) { try { return '\u200d' + revdrec.call(this); } catch (err) { return `\u200d*${err}*`; } } return this.__revdinststr || nameInstance(this, this.constructor.name || '<unknown>'); }; const str_Symbol = function() { return this.__revdinststr || nameInstance(this, this.toString()); }; const str_Generator = function() { return this.__revdinststr || nameInstance(this, 'Generator'); }; const str_AsyncGenerator = function() { return this.__revdinststr || nameInstance(this, 'AsyncGenerator'); }; const rec_Object = function() { if (this.__proto__ !== objProto) { try { objDefProp(this.__proto__, '__revdstr', {configurable: true, writable: true, value: str_Instance}); objDefProp(this.__proto__, '__revdrec', {configurable: true, writable: true, value: false}); } catch {} throw errAsValue; } return str_Object.call(this); }; const str = (obj) => { if (!obj) { if (obj === undefined) return 'undefined'; else if (obj === null) return 'null'; } return obj.__revdstr(obj); }; const strInit = (mutMode, strLen) => { strMax = strLen; strHalf = Math.ceil(strLen / 2); strHalfN = -strHalf; str.function = str_Function; str.boolean = str_Boolean; str.number = str_Number; str.bigint = str_BigInt; str.string = str_String; str.array = mutMode ? ((obj) => str_Array.call(obj)) : ((obj) => str_Instance.call(obj)); str.object = mutMode ? ((obj) => str_Object.call(obj)) : ((obj) => str_Instance.call(obj)); for (const [obj, str, rec] of [ [Function, str_Function], [Boolean, str_Boolean], [Number, str_Number], [BigInt, str_BigInt], [String, str_String], [[Array, str_Instance], [Array, str_Array], [Array, str_Array, str_Array]][mutMode], [[Object, str_Instance], [Object, str_Object], [Object, str_Object, rec_Object]][mutMode], [Error, function() { return this.toString(); }], [Symbol, str_Symbol], [(function*(){})().constructor, str_Generator], [(async function*(){}).constructor.prototype, str_AsyncGenerator], ]) { objDefProp(obj.prototype, '__revdstr', {value: str}); objDefProp(obj.prototype, '__revdrec', {value: rec || false}); } }; const u8Empty = new Uint8Array(); const u8NonError = new Uint8Array([110, 111, 110, 45, 69, 114, 114, 111, 114]); const b64Timestamp = new BigUint64Array(1); const u8Timestamp = new Uint8Array(b64Timestamp.buffer); const serialize = function(states, idx, end, skipTimestamp) { if (!skipTimestamp) b64Timestamp[0] = BigInt(Date.now()) * 1000000n + 621355968000000000n; for (; idx < end; idx++) { const evtId = this.eIds[idx]; if (evtId < 0) { const stmtId = -evtId - 2; const val = this.eVals[idx]; if (val instanceof Error) states.push(pack_CatchState(this.AppId, stmtId, u8Timestamp, textEncode(val.message), stmtId === -1, textEncode(val.stack), textEncode(val.name))); else states.push(pack_CatchState(this.AppId, stmtId, u8Timestamp, textEncode(str(val)), stmtId === -1, u8Empty, u8NonError)); } else { switch (this.eTypes[evtId]) { case 0: states.push(pack_StaticState(this.AppId, this.eStmtIds[evtId], u8Timestamp)); break; case 1: states.push(pack_VariableState(this.AppId, this.eStmtIds[evtId], u8Timestamp, textEncode(str(this.eVals[idx])))); break; case 2: const stmtId = this.eStmtIds[evtId]; const args = this.eVals[idx]; if (args !== undefined) { const argsId = stmtId + 1; const end = args.length - 1; for (let i = 0; i < end; i++) states.push(pack_VariableState(this.AppId, argsId + i, u8Timestamp, textEncode(str(args[i])))); } states.push(pack_StaticState(this.AppId, stmtId, u8Timestamp)); break; case 3: { const stmtId = this.eStmtIds[evtId]; const params = this.eVals[idx]; if (params !== undefined) { const paramsId = stmtId + 1; const end = params.length - 1; for (let i = 0; i < end; i++) states.push(pack_VariableState(this.AppId, paramsId + i, u8Timestamp, textEncode(str(params[i])))); } states.push(pack_MethodState(this.AppId, stmtId, u8Timestamp, 0)); break; } case 4: states.push(pack_MethodState(this.AppId, this.eStmtIds[evtId], u8Timestamp, 1)); break; case 5: states.push(pack_VariableState(this.AppId, this.eStmtXs[evtId], u8Timestamp, textEncode(str(this.eVals[idx])))); states.push(pack_MethodState(this.AppId, this.eStmtIds[evtId], u8Timestamp, 1)); break; case 6: states.push(pack_VariableState(this.AppId, this.eStmtXs[evtId], u8Timestamp, textEncode(str(this.eVals[idx])))); states.push(pack_MethodState(this.AppId, this.eStmtIds[evtId], u8Timestamp, 2)); break; case 7: states.push(pack_MethodState(this.AppId, this.eStmtIds[evtId], u8Timestamp, 3)); break; } } } }; const crashSerialize = function() { const _v = this.v; const _a = this.a; this.v = off_v; this.a = off_a; const states = []; const idx = this.eIdx; if (this.eIds[evtLast] === 0x7fffffff) serialize.call(this, states, 0, idx); else { serialize.call(this, states, idx, evtCount); serialize.call(this, states, 0, idx, true); } this.v = _v; this.a = _a; return states; }; const crash_v = function(evtId, value) { const evtIdx = this.eIdx; this.eIds[evtIdx] = evtId; this.eIdx = (evtIdx + 1) & evtLast; let revdrec; if (value && (revdrec = value.__revdrec)) { const _v = this.v; const _a = this.a; this.v = off_v; this.a = off_a; try { this.eVals[evtIdx] = '\u200d' + revdrec.call(value); } catch (err) { if (err !== errAsValue) this.eVals[evtIdx] = `\u200d*${err}*`; else this.eVals[evtIdx] = value; } this.v = _v; this.a = _a; } else this.eVals[evtIdx] = value; return value; }; const crash_a = function(passthru, ...args) { const evtIdx = this.eIdx; this.eIds[evtIdx] = args[args.length - 1]; this.eVals[evtIdx] = args; this.eIdx = (evtIdx + 1) & evtLast; let revdrec, value; for (let i = args.length - 2; i >= 0; i--) { value = args[i]; if (value && (revdrec = value.__revdrec)) { const _v = this.v; const _a = this.a; this.v = off_v; this.a = off_a; loop: while (true) { try { args[i] = '\u200d' + revdrec.call(value); } catch (err) { if (err !== errAsValue) args[i] = `\u200d*${err}*`; } while (--i >= 0) { value = args[i]; if (value && (revdrec = value.__revdrec)) continue loop; } break; } this.v = _v; this.a = _a; break; } } return passthru; }; const liveStream = function(isLastStates = false) { const _v = this.v; const _a = this.a; this.v = off_v; this.a = off_a; const states = []; const tail = this.eTail; const idx = this.eIdx; if (tail < idx) serialize.call(this, states, tail, idx); else { serialize.call(this, states, tail, evtCount); serialize.call(this, states, 0, idx, true); } this.v = _v; this.a = _a; this.eTail = idx; const tcpFrame = pack_TcpFrame_State(isLastStates ? FrameType_SaveLastStates : FrameType_AppState, states); if (this.queue) this.queue.push(tcpFrame); else this.conn.send(tcpFrame); }; const live_v = function(evtId, value) { const evtIdx = this.eIdx; this.eIds[evtIdx] = evtId; this.eIdx = (evtIdx + 1) & evtLast; let revdrec; if (value && (revdrec = value.__revdrec)) { const _v = this.v; const _a = this.a; this.v = off_v; this.a = off_a; try { this.eVals[evtIdx] = '\u200d' + revdrec.call(value); } catch (err) { if (err !== errAsValue) this.eVals[evtIdx] = `\u200d*${err}*`; else this.eVals[evtIdx] = value; } this.v = _v; this.a = _a; } else this.eVals[evtIdx] = value; if (this.eIdx === this.eTail) liveStream.call(this); return value; }; const live_a = function(passthru, ...args) { const evtIdx = this.eIdx; this.eIds[evtIdx] = args[args.length - 1]; this.eVals[evtIdx] = args; this.eIdx = (evtIdx + 1) & evtLast; let revdrec, value; for (let i = args.length - 2; i >= 0; i--) { value = args[i]; if (value && (revdrec = value.__revdrec)) { const _v = this.v; const _a = this.a; this.v = off_v; this.a = off_a; loop: while (true) { try { args[i] = '\u200d' + revdrec.call(value); } catch (err) { if (err !== errAsValue) args[i] = `\u200d*${err}*`; } while (--i >= 0) { value = args[i]; if (value && (revdrec = value.__revdrec)) continue loop; } break; } this.v = _v; this.a = _a; break; } } if (this.eIdx === this.eTail) liveStream.call(this); return passthru; }; const ntoaValue = '56789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'; const ntoaCount = ' !#$%&*+-./01234'; const atonValue = ntoaValue.split('').reduce((a2n, a, i) => (a2n[a] = i, a2n), {}); const atonCount = ntoaCount.split('').reduce((a2n, a, i) => (a2n[a] = i, a2n), {}); const decodeArray = (out, str, idx) => { const lStr = str.length; let last = 0; let i; for (i = 0; i < lStr;) { let c = str[i++]; if (c < '5') { let n = atonCount[c]; if ((c = str[i++]) < '5') { n = n << 4 | atonCount[c]; if ((c = str[i++]) < '5') { n = n << 4 | atonCount[c]; c = str[i++]; } } c = atonValue[c]; c = c & 1 ? -(c >> 1) : c >> 1; for (let end = idx + n; idx < end;) out[idx++] = last += c; } else { let v = 0; while (true) { c = atonValue[c]; if (!(c & 32)) { v |= c; break; } v = (v | (c & 31)) << 5; c = str[i++]; } out[idx++] = last += (v & 1 ? -(v >> 1) : v >> 1); } } return out; }; revd.es = []; revd.e = -1; revd.str = str; revd.RecMode = { Off: RecMode_Off, Crash: RecMode_Crash, Live: RecMode_Live, OnEvent: RecMode_Crash, Continuous: RecMode_Live }; const str2RecMode = {'standby': RecMode_Off, 'continuous': RecMode_Live, 'onevent': RecMode_Crash, 'live': RecMode_Live, 'crash': RecMode_Crash}; const str2MutMode = {'full': MutMode_Full, 'dirty': MutMode_Dirty, 'none': MutMode_None}; const evtCount = 1024; const evtLast = evtCount - 1; const off_v = (evtId, value) => value; const off_a = (passthru) => passthru; const recModeV = [null, off_v, null, live_v, crash_v]; let snapshotIdx = 1; const setRecMode_off = function() { this.eIds[evtLast] = 0x7fffffff; this.eIdx = 0; this.v = off_v; this.a = off_a; this.recMode = RecMode_Off; }; const setRecMode_crash = function() { this.v = crash_v; this.a = crash_a; this.recMode = RecMode_Crash; }; revd.setRecMode = function(recMode, method = false) { if (recMode === this.recMode || this.v !== recModeV[this.recMode] || typeof recMode !== 'number' || (recMode !== RecMode_Off && recMode !== RecMode_Live && recMode !== RecMode_Crash) || (recMode === RecMode_Live && this.recMax !== RecMode_Live) || (recMode !== RecMode_Off && this.recMax === RecMode_Off)) return; if (this.recMode === RecMode_Live) { if (this.eIdx !== this.eTail) liveStream.call(this, method); if (method === null) { const tcpFrame = pack_TcpFrame_AppBeat(this.Rel, this.Sol, false); if (this.queue) this.queue.push(tcpFrame); else this.conn.send(tcpFrame, false); this.conn.close(false); } } if (recMode === RecMode_Off) setRecMode_off.call(this); else if (recMode === RecMode_Crash) setRecMode_crash.call(this); else { if (this.recMode === RecMode_Crash && this.eIds[evtLast] !== 0x7fffffff) this.eTail = (this.eIdx + 1) & evtLast; else this.eTail = 0; this.v = live_v; this.a = live_a; this.recMode = recMode; if (method === null) { const onclose = onClose.bind(this); this.queue = []; this.conn = connect.call(this, true, onConnect.bind(this), onclose, onclose, onData.bind(this)); } } }; revd.snapshot = function(name) { if (this.recMode === RecMode_Off || this.v !== recModeV[this.recMode]) return; if (!name) name = `Snapshot_${snapshotIdx++}`; const tcpFrame = pack_TcpFrame_Snapshot(this.Sol, this.Rel, textEncode(name), crashSerialize.call(this)); if (this.conn) { if (this.queue) this.queue.push(tcpFrame); else this.conn.send(tcpFrame); } else { const conn = connect.call(this, false, function() { if (conn.send(tcpFrame)) conn.close(false); }, null, null, null); } }; revd.flush = function() { if (this.recMode === RecMode_Live && this.eIdx !== this.eTail && this.v === recModeV[this.recMode]) liveStream.call(this); }; revd.unhandled = function(err, stmtId, exit) { if (this.v === off_v) return; if (stmtId !== undefined) this.v(stmtId, err); else if (this.e !== -1) this.v(this.e < 0 ? this.e : -(this.eStmtIds[this.e] + 2), err); this.v(-1, err); if (this.recMode === RecMode_Live && this.eIdx !== this.eTail) liveStream.call(this); sendException.call(this, crashSerialize.call(this), exit); }; revd.c = function(evtId, err) { if (this.v !== off_v) this.v(evtId < 0 ? evtId : -(this.eStmtIds[evtId] + 2), err); return err; }; revd.init = function(Solution, Application, Release, ApplicationId, AuthToken, host, port, recMode, mutMode, strLen, nEvents, baseEvtId, types, stmtIds, stmtXs, magic, post, fnm) { const lEvents = nEvents + baseEvtId; if (!this.isInit) { recMode = str2RecMode[env.REVDEBUG_MODE] || recMode; this.eIds = new Int32Array(evtCount); this.eVals = new Array(evtCount); this.Sol = textEncode(env.REVDEBUG_SOLUTION || Solution); this.App = textEncode(env.REVDEBUG_APPLICATION || Application); this.Rel = textEncode(env.REVDEBUG_RELEASE || Release); this.AppId = decodeArray(new Uint8Array(16), ApplicationId, 0), this.Auth = textEncode(env.REVDEBUG_AUTH || AuthToken); this.host = env.REVDEBUG_APPLICATIONS_HOST || host; this.port = Number(env.REVDEBUG_APPLICATIONS_PORT) || port; this.recMax = recMode; this.eTypes = new Uint8Array(lEvents); this.eStmtIds = new Int32Array(lEvents); this.eStmtXs = new Int32Array(lEvents); this.conn = null; decodeArray(this.eTypes, types, baseEvtId); decodeArray(this.eStmtIds, stmtIds, baseEvtId); decodeArray(this.eStmtXs, stmtXs, baseEvtId); strInit((n => n >= 0 ? n : mutMode)(str2MutMode[env.REVDEBUG_MUTABLE]), (n => n + !n)(Number(env.REVDEBUG_STRLEN)) || strLen); setRecMode_off.call(this); initSystem.call(this); this.setRecMode(recMode, null); this.isInit = true; } else { if (lEvents > this.eTypes.length) { const evtTypes = new Uint8Array(lEvents); const evtStmtIds = new Int32Array(lEvents); const evtStmtIdXs = new Int32Array(lEvents); evtTypes.set(this.eTypes, 0); evtStmtIds.set(this.eStmtIds, 0); evtStmtIdXs.set(this.eStmtXs, 0); this.eTypes = evtTypes; this.eStmtIds = evtStmtIds; this.eStmtXs = evtStmtIdXs; } decodeArray(this.eTypes, types, baseEvtId); decodeArray(this.eStmtIds, stmtIds, baseEvtId); decodeArray(this.eStmtXs, stmtXs, baseEvtId); } return this; }; }</script>
  <meta charset="utf-8">
  <title>Tour of Heroes</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <app-root></app-root>
</body>
</html>
